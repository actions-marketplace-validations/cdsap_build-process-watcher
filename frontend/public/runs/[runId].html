<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Build Process Watcher - Run Dashboard</title>
    <link rel="icon" type="image/svg+xml" href="/favicon.svg">
    <script src="https://cdn.plot.ly/plotly-2.35.2.min.js"></script>
    <script src="/config.js"></script>
    <script>
        // Set all links dynamically based on config
        (function() {
            const frontendUrl = window.BUILD_PROCESS_WATCHER_CONFIG?.frontendUrl || 'https://process-watcher.web.app';
            document.addEventListener('DOMContentLoaded', function() {
                // Set all "back home" links
                document.querySelectorAll('.back-home-link, a[href="https://process-watcher.web.app"]').forEach(link => {
                    link.href = frontendUrl;
                });
            });
            // Also set immediately for elements that might exist before DOMContentLoaded
            const setLinks = function() {
                document.querySelectorAll('a[href="https://process-watcher.web.app"]').forEach(link => {
                    link.href = frontendUrl;
                });
            };
            if (document.readyState === 'loading') {
                document.addEventListener('DOMContentLoaded', setLinks);
            } else {
                setLinks();
            }
        })();
    </script>
    <style>
        * {
            box-sizing: border-box;
            padding: 0;
            margin: 0;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen', 'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue', sans-serif;
            background: #fff;
            color: #333;
            line-height: 1.6;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }

        header {
            border-bottom: 1px solid #e5e7eb;
            padding: 1rem 0;
            margin-bottom: 2rem;
        }

        h1 {
            font-size: 2rem;
            font-weight: 600;
            color: #111827;
        }

        .run-info {
            background: #f9fafb;
            border: 1px solid #e5e7eb;
            border-radius: 0.5rem;
            padding: 1.5rem;
            margin-bottom: 2rem;
        }

        .status-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 1rem;
            margin-bottom: 2rem;
        }

        .status-card {
            background: white;
            border: 1px solid #e5e7eb;
            border-radius: 0.5rem;
            padding: 1rem;
            text-align: center;
        }

        .status-card h3 {
            font-size: 0.875rem;
            font-weight: 500;
            color: #6b7280;
            margin-bottom: 0.5rem;
        }

        .status-card p {
            font-size: 1.125rem;
            font-weight: 600;
            color: #111827;
        }

        .status-in-progress {
            color: #2563eb;
        }

        .status-completed {
            color: #059669;
        }

        .chart-container {
            background: white;
            border: 1px solid #e5e7eb;
            border-radius: 0.5rem;
            padding: 1.5rem;
            margin-bottom: 2rem;
            overflow-x: auto;
        }

        .downloads-toolbar {
            display: flex;
            gap: 0.5rem;
            flex-wrap: wrap;
            margin: 0 0 1rem 0;
        }

        .btn {
            display: inline-flex;
            align-items: center;
            gap: 0.4rem;
            padding: 0.5rem 0.8rem;
            background: #2563eb;
            color: #fff;
            border: 1px solid #1d4ed8;
            border-radius: 0.375rem;
            font-size: 0.875rem;
            text-decoration: none;
            cursor: pointer;
        }

        .btn.secondary {
            background: #6b7280;
            border-color: #4b5563;
        }

        .chart-wrapper {
            min-width: 600px;
            width: 100%;
        }

        .loading {
            text-align: center;
            padding: 2rem;
            color: #6b7280;
        }

        .error {
            background: #fef2f2;
            border: 1px solid #fecaca;
            border-radius: 0.5rem;
            padding: 1.5rem;
            color: #dc2626;
            text-align: center;
        }

        .not-found {
            background: #fefce8;
            border: 1px solid #fde68a;
            border-radius: 0.5rem;
            padding: 1.5rem;
            color: #a16207;
            text-align: center;
        }

        .refresh-controls {
            background: #f0f9ff;
            border: 1px solid #bae6fd;
            border-radius: 0.5rem;
            padding: 1rem;
            margin-bottom: 2rem;
            display: flex;
            align-items: center;
            gap: 1rem;
            flex-wrap: wrap;
        }

        .refresh-controls label {
            font-weight: 500;
            color: #0369a1;
        }

        .refresh-controls select {
            padding: 0.5rem;
            border: 1px solid #7dd3fc;
            border-radius: 0.375rem;
            background: white;
            color: #0c4a6e;
            font-size: 0.875rem;
            cursor: pointer;
        }

        .refresh-controls .status-text {
            color: #0369a1;
            font-size: 0.875rem;
        }

        .refresh-info {
            background: #f0f9ff;
            border: 1px solid #bae6fd;
            border-radius: 0.5rem;
            padding: 1rem;
            color: #0369a1;
            font-size: 0.875rem;
            margin-bottom: 1rem;
        }

        @media (max-width: 768px) {
            .status-grid {
                grid-template-columns: repeat(2, 1fr);
            }
            
            .chart-container {
                padding: 1rem;
                margin: 0 -10px 2rem -10px;
                border-radius: 0;
            }
            
            .chart-wrapper {
                min-width: 500px;
            }
            
            .container {
                padding: 10px;
            }
            
            h1 {
                font-size: 1.5rem;
            }
            
            .run-info h2 {
                font-size: 1.25rem;
            }
        }
        
        @media (max-width: 480px) {
            .status-grid {
                grid-template-columns: 1fr;
            }
            
            .chart-wrapper {
                min-width: 400px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>Build Process Watcher</h1>
        </header>

        <div id="content">
            <div class="loading">
                <p>Loading run data...</p>
            </div>
        </div>
    </div>

    <script>
        // Get run ID from URL
        const pathParts = window.location.pathname.split('/');
        const runId = pathParts[pathParts.length - 1];
        
        // Refresh interval management
        let refreshInterval = parseInt(localStorage.getItem('refreshInterval')) || 60; // Default 60 seconds
        let refreshTimer = null;
        let lastRefreshTime = null;
        
        if (!runId || runId === 'runs' || runId === '') {
            document.getElementById('content').innerHTML = `
                <div class="error">
                    <h2>Invalid Run ID</h2>
                    <p>No run ID provided in the URL.</p>
                    <a href="#" class="back-home-link" style="color: #2563eb;">Back to Home</a>
                </div>
            `;
        } else {
            loadRunData(runId);
        }

        function setRefreshInterval(seconds) {
            refreshInterval = seconds;
            localStorage.setItem('refreshInterval', seconds);
            
            // Cancel existing timer and restart with new interval
            if (refreshTimer) {
                clearTimeout(refreshTimer);
                refreshTimer = null;
            }
            
            // Reload immediately to show the new interval in UI
            loadRunData(runId);
        }

        function cancelRefresh() {
            if (refreshTimer) {
                clearTimeout(refreshTimer);
                refreshTimer = null;
            }
        }

        async function loadRunData(runId) {
            const backendUrl = window.BUILD_PROCESS_WATCHER_CONFIG?.backendUrl || 'https://build-process-watcher-backend-685615422311.us-central1.run.app';
            
            try {
                const response = await fetch(`${backendUrl}/runs/${runId}`);
                
                if (!response.ok) {
                    if (response.status === 404) {
                        showNotFound(runId);
                    } else {
                        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                    }
                    return;
                }

                const data = await response.json();
                lastRefreshTime = new Date();
                renderDashboard(runId, data);
                window.currentRunData = data;
                
                // Auto-refresh if not finished
                cancelRefresh(); // Cancel any existing timer
                if (!data.finished) {
                    refreshTimer = setTimeout(() => loadRunData(runId), refreshInterval * 1000);
                }
                
            } catch (error) {
                console.error('Error loading run data:', error);
                showError(error.message);
            }
        }

        function renderDashboard(runId, data) {
            const isFinished = data.finished;
            const samples = data.samples || [];
            window.currentSamples = samples;
            
            const refreshStatus = isFinished ? 'Stopped' : `Active (${refreshInterval}s)`;
            const lastRefreshText = lastRefreshTime ? lastRefreshTime.toLocaleTimeString() : 'Never';
            
            document.getElementById('content').innerHTML = `
                <div class="run-info">
                    <h2>Run Details</h2>
                    <p><strong>Run ID:</strong> <code>${runId}</code></p>
                    ${data.finished_at ? `<p><strong>Finished:</strong> ${new Date(data.finished_at).toLocaleString()}</p>` : ''}
                    ${data.updated_at ? `<p><strong>Last Updated:</strong> ${new Date(data.updated_at).toLocaleString()}</p>` : ''}
                </div>

                ${!isFinished ? `
                    <div class="refresh-controls">
                        <label for="refreshInterval">ðŸ”„ Auto-refresh interval:</label>
                        <select id="refreshInterval" onchange="setRefreshInterval(parseInt(this.value))">
                            <option value="5" ${refreshInterval === 5 ? 'selected' : ''}>5 seconds</option>
                            <option value="10" ${refreshInterval === 10 ? 'selected' : ''}>10 seconds</option>
                            <option value="30" ${refreshInterval === 30 ? 'selected' : ''}>30 seconds</option>
                            <option value="60" ${refreshInterval === 60 ? 'selected' : ''}>1 minute</option>
                            <option value="120" ${refreshInterval === 120 ? 'selected' : ''}>2 minutes</option>
                            <option value="300" ${refreshInterval === 300 ? 'selected' : ''}>5 minutes</option>
                        </select>
                        <span class="status-text">Last refresh: ${lastRefreshText}</span>
                    </div>
                ` : ''}

                <div class="status-grid">
                    <div class="status-card">
                        <h3>Status</h3>
                        <p class="${isFinished ? 'status-completed' : 'status-in-progress'}">
                            ${isFinished ? 'Completed' : 'In Progress'}
                        </p>
                    </div>
                    <div class="status-card">
                        <h3>Samples</h3>
                        <p>${samples.length}</p>
                    </div>
                    <div class="status-card">
                        <h3>Processes</h3>
                        <p>${new Set(samples.map(s => `${s.Name}|${s.PID}`)).size}</p>
                    </div>
                    <div class="status-card">
                        <h3>Auto-refresh</h3>
                        <p>${refreshStatus}</p>
                    </div>
                </div>

                <div class="chart-container">
                    <div class="downloads-toolbar">
                        <button class="btn" id="btn-download-png">Download PNG</button>
                        <button class="btn" id="btn-download-svg">Download SVG</button>
                        <button class="btn secondary" id="btn-download-json">Download JSON</button>
                        <button class="btn secondary" id="btn-download-csv">Download CSV</button>
                    </div>
                    <h3>Memory Usage Over Time</h3>
                    <div class="chart-wrapper">
                        <div id="chart" style="width: 100%; height: 500px;"></div>
                    </div>
                </div>

                ${hasGCData(samples) ? `
                <div class="chart-container">
                    <div class="downloads-toolbar">
                        <button class="btn" id="btn-download-gc-png">Download GC PNG</button>
                        <button class="btn" id="btn-download-gc-svg">Download GC SVG</button>
                    </div>
                    <h3>Garbage Collection Time Over Time</h3>
                    <div class="chart-wrapper">
                        <div id="gc-chart" style="width: 100%; height: 500px;"></div>
                    </div>
                </div>
                ` : ''}
            `;

            if (samples.length > 0) {
                renderChart(samples);
                if (hasGCData(samples)) {
                    renderGCChart(samples);
                }
            }

            // Wire download buttons
            const btnPng = document.getElementById('btn-download-png');
            const btnSvg = document.getElementById('btn-download-svg');
            const btnJson = document.getElementById('btn-download-json');
            const btnCsv = document.getElementById('btn-download-csv');
            const btnGcPng = document.getElementById('btn-download-gc-png');
            const btnGcSvg = document.getElementById('btn-download-gc-svg');

            if (btnPng) btnPng.onclick = () => downloadChart('png');
            if (btnSvg) btnSvg.onclick = () => downloadChart('svg');
            if (btnJson) btnJson.onclick = () => downloadJson(runId);
            if (btnCsv) btnCsv.onclick = () => downloadCsv(runId);
            if (btnGcPng) btnGcPng.onclick = () => downloadGCChart('png');
            if (btnGcSvg) btnGcSvg.onclick = () => downloadGCChart('svg');
        }

        function hasGCData(samples) {
            return samples.some(sample => sample.GCTime !== undefined && sample.GCTime !== null && sample.GCTime > 0);
        }

        function renderGCChart(samples) {
            // Process data for GC chart - group by both Name and PID to handle multiple processes with same name
            const timestamps = [...new Set(samples.map(s => s.Timestamp))].sort((a, b) => a - b);
            // Create unique process keys (Name + PID combination)
            const processKeys = [...new Set(samples.map(s => `${s.Name}|${s.PID}`))];
            
            const traces = [];
            const colors = ['#e74c3c', '#f39c12', '#9b59b6', '#2ecc71', '#3498db', '#e67e22'];
            
            // Create traces for each unique process (Name + PID combination)
            processKeys.forEach((processKey, index) => {
                const color = colors[index % colors.length];
                const [processName, pid] = processKey.split('|');
                
                // GC time data - use null for timestamps where process doesn't exist yet
                // Convert from milliseconds (stored in DB) to seconds (for display)
                const gcData = timestamps.map(timestamp => {
                    const sample = samples
                        .filter(s => s.Name === processName && s.PID === pid && s.Timestamp === timestamp)
                        [0];
                    return sample && sample.GCTime !== undefined && sample.GCTime !== null && sample.GCTime > 0 ? sample.GCTime / 1000 : null;
                });
                
                traces.push({
                    x: timestamps.map(t => new Date(t)),
                    y: gcData,
                    type: 'scatter',
                    mode: 'lines+markers',
                    name: `${processName} PID:${pid}`,
                    line: { color: color, width: 3 },
                    marker: { size: 6, color: color },
                    connectgaps: false
                });
            });

            // Detect if mobile
            const isMobile = window.innerWidth < 768;
            
            const layout = {
                title: isMobile ? '' : 'Garbage Collection Time Over Time',
                xaxis: { 
                    title: 'Time',
                    tickformat: isMobile ? '%H:%M' : '%H:%M:%S',
                    tickangle: isMobile ? -45 : 0
                },
                yaxis: { title: 'GC Time (s)' },
                showlegend: true,
                legend: { 
                    x: isMobile ? 0.5 : 1.02, 
                    y: isMobile ? -0.2 : 1,
                    xanchor: isMobile ? 'center' : 'left',
                    orientation: isMobile ? 'h' : 'v'
                },
                margin: { 
                    l: isMobile ? 50 : 60, 
                    r: isMobile ? 20 : 100, 
                    t: isMobile ? 20 : 40, 
                    b: isMobile ? 80 : 60 
                },
                font: {
                    size: isMobile ? 10 : 12
                }
            };

            const config = {
                responsive: true,
                displayModeBar: true,
                displaylogo: false,
                modeBarButtonsToRemove: ['pan2d', 'lasso2d', 'select2d', 'autoScale2d'],
                toImageButtonOptions: {
                    format: 'png',
                    filename: `build-monitor-gc-${runId}`,
                    height: isMobile ? 400 : 500,
                    width: isMobile ? 800 : 1000,
                    scale: 2
                }
            };

            Plotly.newPlot('gc-chart', traces, layout, config);
            
            // Handle window resize
            window.addEventListener('resize', function() {
                Plotly.Plots.resize('gc-chart');
            });
        }

        function renderRssHeapRatioChart(samples) {
            // Process data for RSS/Heap ratio chart - group by both Name and PID to handle multiple processes with same name
            const timestamps = [...new Set(samples.map(s => s.Timestamp))].sort((a, b) => a - b);
            // Create unique process keys (Name + PID combination)
            const processKeys = [...new Set(samples.map(s => `${s.Name}|${s.PID}`))];
            
            const traces = [];
            const colors = ['#e74c3c', '#f39c12', '#9b59b6', '#2ecc71', '#3498db', '#e67e22', '#1abc9c', '#e91e63'];
            
            // Create traces for each unique process (Name + PID combination)
            processKeys.forEach((processKey, index) => {
                const color = colors[index % colors.length];
                const [processName, pid] = processKey.split('|');
                
                // RSS/Heap ratio data - use null for timestamps where process doesn't exist yet or heap is 0
                const ratioData = timestamps.map(timestamp => {
                    const sample = samples
                        .filter(s => s.Name === processName && s.PID === pid && s.Timestamp === timestamp)
                        [0];
                    if (sample && sample.HeapUsed && sample.HeapUsed > 0) {
                        return sample.RSS / sample.HeapUsed;
                    }
                    return null;
                });
                
                traces.push({
                    x: timestamps.map(t => new Date(t)),
                    y: ratioData,
                    type: 'scatter',
                    mode: 'lines+markers',
                    name: `${processName} PID:${pid}`,
                    line: { color: color, width: 3 },
                    marker: { size: 6, color: color },
                    connectgaps: false
                });
            });

            // Detect if mobile
            const isMobile = window.innerWidth < 768;
            
            const layout = {
                title: isMobile ? '' : 'RSS/Heap Ratio Over Time',
                xaxis: { 
                    title: 'Time',
                    tickformat: isMobile ? '%H:%M' : '%H:%M:%S',
                    tickangle: isMobile ? -45 : 0
                },
                yaxis: { title: 'RSS/Heap Ratio' },
                showlegend: true,
                legend: { 
                    x: isMobile ? 0.5 : 1.02, 
                    y: isMobile ? -0.2 : 1,
                    xanchor: isMobile ? 'center' : 'left',
                    orientation: isMobile ? 'h' : 'v'
                },
                margin: { 
                    l: isMobile ? 50 : 60, 
                    r: isMobile ? 20 : 100, 
                    t: isMobile ? 20 : 40, 
                    b: isMobile ? 80 : 60 
                },
                font: {
                    size: isMobile ? 10 : 12
                }
            };

            const config = {
                responsive: true,
                displayModeBar: true,
                displaylogo: false,
                modeBarButtonsToRemove: ['pan2d', 'lasso2d', 'select2d', 'autoScale2d'],
                toImageButtonOptions: {
                    format: 'png',
                    filename: `build-monitor-rss-heap-${runId}`,
                    height: isMobile ? 400 : 500,
                    width: isMobile ? 800 : 1000,
                    scale: 2
                }
            };

            Plotly.newPlot('rss-heap-chart', traces, layout, config);
            
            // Handle window resize
            window.addEventListener('resize', function() {
                Plotly.Plots.resize('rss-heap-chart');
            });
        }

        function renderChart(samples) {
            // Process data for chart - group by both Name and PID to handle multiple processes with same name
            const timestamps = [...new Set(samples.map(s => s.Timestamp))].sort((a, b) => a - b);
            // Create unique process keys (Name + PID combination)
            const processKeys = [...new Set(samples.map(s => `${s.Name}|${s.PID}`))];
            
            const traces = [];
            const colors = ['#3498db', '#e74c3c', '#9b59b6', '#2ecc71', '#f39c12', '#e67e22'];
            
            // Create traces for each unique process (Name + PID combination)
            processKeys.forEach((processKey, index) => {
                const color = colors[index % colors.length];
                const [processName, pid] = processKey.split('|');
                
                // RSS data - use null for timestamps where process doesn't exist yet
                const rssData = timestamps.map(timestamp => {
                    const sample = samples
                        .filter(s => s.Name === processName && s.PID === pid && s.Timestamp === timestamp)
                        [0];
                    return sample ? sample.RSS : null;  // null means "no data" - line won't appear
                });
                
                traces.push({
                    x: timestamps.map(t => new Date(t)),
                    y: rssData,
                    type: 'scatter',
                    mode: 'lines',
                    name: `${processName} PID:${pid} (RSS)`,
                    line: { color: color, width: 3 },
                    connectgaps: false  // Don't connect across null values
                });
                
                // Heap data - use null for timestamps where process doesn't exist yet
                const heapData = timestamps.map(timestamp => {
                    const sample = samples
                        .filter(s => s.Name === processName && s.PID === pid && s.Timestamp === timestamp)
                        [0];
                    return sample ? sample.HeapUsed : null;  // null means "no data" - line won't appear
                });
                
                traces.push({
                    x: timestamps.map(t => new Date(t)),
                    y: heapData,
                    type: 'scatter',
                    mode: 'lines',
                    name: `${processName} PID:${pid} (Heap)`,
                    line: { color: color, width: 2, dash: 'dash' },
                    connectgaps: false  // Don't connect across null values
                });
            });
            
            // Add total memory trace - only sum processes that exist at this exact timestamp
            const totalData = timestamps.map(timestamp => {
                let total = 0;
                processKeys.forEach(processKey => {
                    const [processName, pid] = processKey.split('|');
                    const sample = samples
                        .filter(s => s.Name === processName && s.PID === pid && s.Timestamp === timestamp)
                        [0];
                    if (sample) total += sample.RSS;
                });
                return total > 0 ? total : null;  // null if no processes exist yet
            });
            
            traces.push({
                x: timestamps.map(t => new Date(t)),
                y: totalData,
                type: 'scatter',
                mode: 'lines',
                name: 'Total RSS Memory',
                line: { color: '#2c3e50', width: 4 },
                connectgaps: false  // Don't connect across null values
            });

            // Detect if mobile
            const isMobile = window.innerWidth < 768;
            
            const layout = {
                title: isMobile ? '' : 'Memory Usage Over Time', // Hide title on mobile to save space
                xaxis: { 
                    title: 'Time',
                    tickformat: isMobile ? '%H:%M' : '%H:%M:%S', // Shorter time format on mobile
                    tickangle: isMobile ? -45 : 0
                },
                yaxis: { title: 'Memory (MB)' },
                showlegend: true,
                legend: { 
                    x: isMobile ? 0.5 : 1.02, 
                    y: isMobile ? -0.2 : 1,
                    xanchor: isMobile ? 'center' : 'left',
                    orientation: isMobile ? 'h' : 'v'
                },
                margin: { 
                    l: isMobile ? 50 : 60, 
                    r: isMobile ? 20 : 100, 
                    t: isMobile ? 20 : 40, 
                    b: isMobile ? 80 : 60 
                },
                font: {
                    size: isMobile ? 10 : 12
                }
            };

            const config = {
                responsive: true,
                displayModeBar: true,
                displaylogo: false,
                modeBarButtonsToRemove: ['pan2d', 'lasso2d', 'select2d', 'autoScale2d'],
                toImageButtonOptions: {
                    format: 'png',
                    filename: `build-monitor-${runId}`,
                    height: isMobile ? 400 : 500,
                    width: isMobile ? 800 : 1000,
                    scale: 2
                }
            };

            Plotly.newPlot('chart', traces, layout, config);
            
            // Handle window resize
            window.addEventListener('resize', function() {
                Plotly.Plots.resize('chart');
            });
        }

        async function downloadChart(format) {
            try {
                const chart = document.getElementById('chart');
                const isMobile = window.innerWidth < 768;
                const filename = `build-monitor-${runId}`;
                const opts = {
                    format: format,
                    filename: filename,
                    height: isMobile ? 400 : 500,
                    width: isMobile ? 800 : 1000,
                    scale: 2
                };
                const url = await Plotly.toImage(chart, opts);
                const a = document.createElement('a');
                a.href = url;
                a.download = `${filename}.${format}`;
                document.body.appendChild(a);
                a.click();
                a.remove();
            } catch (e) {
                console.error('Failed to export chart:', e);
            }
        }

        async function downloadGCChart(format) {
            try {
                const chart = document.getElementById('gc-chart');
                const isMobile = window.innerWidth < 768;
                const filename = `build-monitor-gc-${runId}`;
                const opts = {
                    format: format,
                    filename: filename,
                    height: isMobile ? 400 : 500,
                    width: isMobile ? 800 : 1000,
                    scale: 2
                };
                const url = await Plotly.toImage(chart, opts);
                const a = document.createElement('a');
                a.href = url;
                a.download = `${filename}.${format}`;
                document.body.appendChild(a);
                a.click();
                a.remove();
            } catch (e) {
                console.error('Failed to export GC chart:', e);
            }
        }

        function downloadJson(runId) {
            try {
                const data = window.currentRunData || {};
                const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `build-monitor-${runId}.json`;
                document.body.appendChild(a);
                a.click();
                a.remove();
                URL.revokeObjectURL(url);
            } catch (e) {
                console.error('Failed to download JSON:', e);
            }
        }

        function downloadCsv(runId) {
            try {
                const samples = window.currentSamples || [];
                if (!samples.length) return;
                const hasGC = hasGCData(samples);
                const header = hasGC ? 
                    ['timestamp','elapsed_time','pid','name','rss_mb','heap_used_mb','heap_capacity_mb','gc_time_s'] :
                    ['timestamp','elapsed_time','pid','name','rss_mb','heap_used_mb','heap_capacity_mb'];
                const rows = samples.map(s => {
                    const baseRow = [
                        s.Timestamp,
                        s.ElapsedTime,
                        s.PID,
                        s.Name,
                        s.RSS,
                        s.HeapUsed,
                        s.HeapCap
                    ];
                    if (hasGC) {
                        // Convert from milliseconds (stored in DB) to seconds (for display)
                        baseRow.push(s.GCTime ? (s.GCTime / 1000).toFixed(3) : 0);
                    }
                    return baseRow;
                });
                const csv = [header.join(','), ...rows.map(r => r.map(escapeCsv).join(','))].join('\n');
                const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `build-monitor-${runId}.csv`;
                document.body.appendChild(a);
                a.click();
                a.remove();
                URL.revokeObjectURL(url);
            } catch (e) {
                console.error('Failed to download CSV:', e);
            }
        }

        function escapeCsv(value) {
            if (value === undefined || value === null) return '';
            const str = String(value);
            if (str.includes(',') || str.includes('"') || str.includes('\n')) {
                return '"' + str.replace(/"/g, '""') + '"';
            }
            return str;
        }

        function showNotFound(runId) {
            document.getElementById('content').innerHTML = `
                <div class="not-found">
                    <h2>Run Not Found</h2>
                    <p>The build run with ID <code>${runId}</code> could not be found.</p>
                    <p>This might be because:</p>
                    <ul style="text-align: left; max-width: 400px; margin: 0 auto;">
                        <li>The memory report has expired (available for 3 hours)</li>
                        <li>The run ID is incorrect</li>
                        <li>The build is still in progress</li>
                    </ul>
                    <a href="https://process-watcher.web.app" style="color: #2563eb; text-decoration: none;">Back to Home</a>
                </div>
            `;
        }

        function showError(message) {
            document.getElementById('content').innerHTML = `
                <div class="error">
                    <h2>Error Loading Data</h2>
                    <p>Failed to load run data: ${message}</p>
                    <a href="https://process-watcher.web.app" style="color: #2563eb; text-decoration: none;">Back to Home</a>
                </div>
            `;
        }
    </script>

    <footer style="margin-top: 4rem; padding: 2rem 1rem; border-top: 1px solid #e5e7eb; text-align: center; color: #6b7280; font-size: 0.875rem;">
        <div style="max-width: 1200px; margin: 0 auto;">
            <p style="margin-bottom: 1rem;">
                Build Process Watcher - Monitor your Gradle builds
            </p>
            <div style="display: flex; justify-content: center; gap: 2rem; flex-wrap: wrap;">
                <a href="https://process-watcher.web.app" style="color: #2563eb; text-decoration: none;">
                    Home
                </a>
                <a href="https://github.com/cdsap/build-process-watcher" target="_blank" rel="noopener noreferrer" style="color: #2563eb; text-decoration: none;">
                    GitHub Repository
                </a>
                <a href="https://github.com/marketplace/actions/build-process-watcher" target="_blank" rel="noopener noreferrer" style="color: #2563eb; text-decoration: none;">
                    GitHub Action
                </a>
            </div>
            <p style="margin-top: 1rem; font-size: 0.75rem; color: #9ca3af;">
                Memory reports are available for 3 hours Â· Free service
            </p>
        </div>
    </footer>
</body>
</html>